---
title: "AM10 Group Project 1"
author: "Group 1: Alex Scheuer, Dhruvi Mundra, Heng Jian Shun, Marta Wnek, Sharon Wenyu Xu, Xueying Liu"
date: "`r Sys.Date()`"
output: html_document
output:
  html_document:
    theme: flatly
    highlight: zenburn
    number_sections: yes
    toc: yes
    toc_float: yes
    code_folding: show
---

```{r, setup, echo=FALSE}
knitr::opts_chunk$set(
  message = FALSE, 
  warning = FALSE, 
  tidy=FALSE,     # display code as typed
  size="small")   # slightly smaller font for code
options(digits = 3)

# default figure size
knitr::opts_chunk$set(
  fig.width=6.75, 
  fig.height=6.75,
  fig.align = "center"
)
```

```{r, load_libraries, include = FALSE}
library(tidyverse) # the usual stuff: dplyr, readr, and other goodies
library(lubridate) # to handle dates
library(GGally) # for correlation-scatter plot matrix
library(ggfortify) # to produce residual diagnostic plots
library(janitor) # clean_names()
library(broom) # use broom:augment() to get tidy table with 
library(extrafont)
library(vroom)
library(ggtext)
library(gapminder)
library(ggrepel)
library(patchwork)
library(gghighlight)
library(skimr)
```

# Introduction

## Load the data

```{r, load_data, warning=FALSE, message=FALSE}
animeinfo_raw <- read_csv(here::here("anime.csv")) %>%
  clean_names() # use janitor::clean_names()

animerating_raw <- read_csv(here::here("animelist.csv")) %>%
  clean_names() # use janitor::clean_names()
```

# ICE the data: Inspect, Clean, Explore

Any data science engagement starts with ICE. Inspecting, Clean and Explore the data.

## Inspect the data

Inspect the data to understand what different variables mean. Variable definitions can be found in the excel version of the data.

### Anime List data

```{r, Inspect anime list data}
glimpse(animeinfo_raw)
skimr::skim(animeinfo_raw)

# Check through each factor columns and inspect number of unique factors.
unique(animelist$type)
unique(animelist$source)
unique(animelist$rating)
# These columns are fine - There are distinct categories for each

```

### Anime Ratings data

```{r, Inspect anime ratings data}
glimpse(animerating_raw)
skimr::skim(animerating_raw)

```

## Clean the data

-   Clean names

-   Remove redundant columns

-   Remove rows that contain cells with missing values for score since that is the most important one

-   Change variable types where needed

-   Isolate date in which anime started airing

-   Create indicator variables for year, month, week, day for "aired from"

-   Re-calculate duration of anime as minutes

-   Extract date premiered in terms of year and season

-   Extract multi-value columns (genres, licensors, producers, studios) and create binary columns for each

### Clean Anime List data

```{r, clean anime list data, warning=FALSE}
animelist_intermediate <- animeinfo_raw %>%
  select(-c(english_name, japanese_name)) %>% #drop redundant columns 
  dplyr::mutate(across(c(score, episodes, ranked), as.numeric)) %>% #convert to numeric
  dplyr::mutate(across(score_10:score_1, as.numeric)) %>% #convert to numeric
  drop_na(score) %>% #drop rows with "Unknown" scores
  
  dplyr::mutate(aired_from = str_split(aired, "to", simplify = T)[, 1]) %>% 
  mutate(
    aired_from = mdy(aired_from),
    aired_from_year = year(aired_from),
    aired_from_month = month(aired_from),
    aired_from_week = week(aired_from),
    aired_from_day = day(aired_from)
    ) %>% #cleaned aired_from
  select(-c(aired)) %>% #drop aired 
  
  mutate(
    duration_hour = str_extract(duration, "(\\d)+(?= hr)"),
    duration_hour = ifelse(is.na(duration_hour), 0, as.numeric(duration_hour)),
    duration_min = as.numeric(str_extract(duration, "(\\d)+(?= min)")),
    duration = (duration_hour * 60) + duration_min #cleaned duration - number of minutes
    ) %>%
  select(-c(duration_hour, duration_min)) %>% #drop duration_hour and duration_min
  
  mutate(
    premier_season = str_extract(premiered, "\\D+"),
    premier_year = as.numeric(str_extract(premiered, "\\d+"))) %>% 
  select(-c(premiered)) #drop premiered
  
glimpse(animelist_intermediate)
  
########################
# Replace (creating binary columns) and remove multi-valued columns (genres, licensors, producers, studios)
animelist_clean <- animelist_intermediate %>% 
  mutate(genre = strsplit(genres, ", ")) %>%
  unnest(genre) %>% 
  arrange(genre) %>%  
  pivot_wider(names_from = genre,
              names_prefix = "genre_", names_repair = "universal",
              values_from = genre, values_fill = 0, values_fn = length) %>% #binary genres
  
  mutate(licensor = strsplit(licensors, ", ")) %>%
  unnest(licensor) %>% 
  arrange(licensor) %>%  
  pivot_wider(names_from = licensor,
              names_prefix = "licensor_", names_repair = "universal",
              values_from = licensor, values_fill = 0, values_fn = length) %>% #binary licensors
  
  mutate(producer = strsplit(producers, ", ")) %>%
  unnest(producer) %>% 
  arrange(producer) %>%  
  pivot_wider(names_from = producer,
              names_prefix = "producer_", names_repair = "universal",
              values_from = producer, values_fill = 0, values_fn = length) %>% #binary producers
  
  mutate(studio = strsplit(studios, ", ")) %>%
  unnest(studio) %>% 
  arrange(studio) %>%  
  pivot_wider(names_from = studio,
              names_prefix = "studio_", names_repair = "universal",
              values_from = studio, values_fill = 0, values_fn = length) %>% #binary studios
  clean_names() %>% 
  select(-c(genres, licensors, producers, studios)) %>%  #drop multivalue columns
  arrange(mal_id) #arrange by anime id for ease
  


```

### Clean Anime Ratings data

```{r, clean anime ratings data, warning=FALSE}
# Store all unique anime IDs as list
uniqueid <- unique(animelist_clean$mal_id)

rating_clean <- animerating_raw %>% 
  filter(anime_id %in% uniqueid)

```

## Explore

### User recommendation








```{r, clusters}
#### focus only on tasting points and so ignore geographical coordinates
animelist_clean_genres<- animelist_clean %>% select(genre_action : genre_yuri)
#### scale data: By scaling we substract the average value of a column from each observation and divide each observation by the standard deviation of the column it belongs to
animelist_clean_genres<-data.frame(scale(animelist_clean_genres))

```

```{r prepare-data2, message=FALSE, warning=FALSE}
library(factoextra)

model_kmeans_2clusters<-eclust(animelist_clean_genres, "kmeans", k = 2,nstart = 50, graph = FALSE)

#Let's check the components of this object.
summary(model_kmeans_2clusters)

#Size of the clusters

model_kmeans_2clusters$size
```

```{r prepare-cluster centers, message=FALSE, warning=FALSE}

#Plot centers for k=2

#First generate a new data frame with cluster centers and cluster numbers
cluster_centers<-data.frame(cluster=as.factor(c(1:2)),model_kmeans_2clusters$centers)

#transpose this data frame
cluster_centers_t<-cluster_centers %>% gather(variable,value,-cluster,factor_key = TRUE)

#plot the centers
graphkmeans_2clusters<-ggplot(cluster_centers_t, aes(x = variable, y = value))+  geom_line(aes(color =cluster,group = cluster), linetype = "dashed",size=1)+ geom_point(size=1,shape=4)+geom_hline(yintercept=0)+theme(text = element_text(size=10),
        axis.text.x = element_text(angle=45, hjust=1),)+ggtitle("K-means Centers k=2")

graphkmeans_2clusters




```

```{r prepare-PCA, message=FALSE, warning=FALSE}

fviz_cluster(model_kmeans_2clusters, whisky_tasting_notes, palette = "Set2", ggtheme = theme_minimal())
```

```{r kmeans-elbow, message=FALSE, warning=FALSE}
library(purrr) #a package for writing succinctfor loops

# Use map_dbl to run K-Means models with varying value of k 
tot_withinss <- map_dbl(1:10,  function(k){
  model <- kmeans(x = animelist_clean_genres, centers = k,iter.max = 100, nstart = 10)
  model$tot.withinss
})

# Generate a data frame containing both k and tot_withinss
elbow_df <- data.frame(
  k = 1:10 ,
  tot_withinss = tot_withinss
)

# Plot the elbow plot
ggplot(elbow_df, aes(x = k, y = tot_withinss)) +
  geom_line() +
  scale_x_continuous(breaks = 1:10)

#Here is a short way of producing the elbow chart using "fviz_nbclust" function. 
fviz_nbclust(animelist_clean_genres,kmeans, method = "wss")+
  labs(subtitle = "Elbow method")
```

```{r kmeans-PCA number of clusters, message=FALSE, warning=FALSE}

# eclust function (part of factoextra) makes it easier to visuliaze clustering results
model_km2 <- eclust(animelist_clean_genres, "kmeans", k = 2,nstart = 50, graph = FALSE)
model_km2$size
model_km3 <- eclust(animelist_clean_genres, "kmeans", k = 3,nstart = 50, graph = FALSE)
model_km3$size
model_km4 <- eclust(animelist_clean_genres, "kmeans", k = 4,nstart = 50, graph = FALSE)
model_km4$size
model_km5 <- eclust(animelist_clean_genres, "kmeans", k = 5,nstart = 50, graph = FALSE)
model_km5$size
 
# plots to compare
#I use the fviz_cluster function which is part of the`factoextra` library
p1 <- fviz_cluster(model_km2, geom = "point", data = animelist_clean_genres) + ggtitle("k = 2")
p2 <- fviz_cluster(model_km3, geom = "point",  data = animelist_clean_genres) + ggtitle("k = 3")
p3 <- fviz_cluster(model_km4, geom = "point",  data = animelist_clean_genres) + ggtitle("k = 4")
p4 <- fviz_cluster(model_km5, geom = "point",  data = animelist_clean_genres) + ggtitle("k = 5")

library(gridExtra)
grid.arrange(p1, p2,p3,p4, nrow = 2)
```

```{r ffg}
s2<-fviz_silhouette(model_km2)+ ggtitle(paste("k = 2", "avg sw=",format(round(model_km2$silinfo$avg.width,3))))
s3<-fviz_silhouette(model_km3)+ ggtitle(paste("k = 3", "avg sw=",format(round(model_km3$silinfo$avg.width,3))))
s4<-fviz_silhouette(model_km4)+ ggtitle(paste("k = 4", "avg sw=",format(round(model_km4$silinfo$avg.width,3))))
s5<-fviz_silhouette(model_km5)+ ggtitle(paste("k = 5", "avg sw=",format(round(model_km5$silinfo$avg.width,3))))
grid.arrange(s2, s3,s4,s5, nrow = 2)

```


